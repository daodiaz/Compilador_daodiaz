package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  			program;
non terminal Axiom		axiom;
non terminal  			epsilon;
non terminal  			defconstantes;
non terminal  			valorconstante;
non terminal  			seccionconstantes;
non terminal  			deftipos;
non terminal  			tipovector;
non terminal  			valorango;
non terminal  			secciontipos;
non terminal  			defvariables;
non terminal			tipovariable;
non terminal  			listavariables;
non terminal  			seccionvariables;
non terminal  			defsubprograma;
non terminal			puntoycomaopcional;

non terminal 			tiporetornofuncion;
non terminal  			seccionsubprograma;
non terminal  			defprincipal;
non terminal			selectorvalororeferencia;


non terminal			expresion;
non terminal			expresionlvl2;
non terminal			expresionlvl3;
non terminal			expresionlvl4;
non terminal			expresionlvl5;




non terminal			miembrovector;
non terminal			procedimiento;
non terminal			funcion;
non terminal			selectorpof;

non terminal            parametrofuncionoproc;
non terminal 			llamadafuncion ; 

non terminal 			parteizquierdaasignacion;  
non terminal 			sentenciadeasignacion;

non terminal 			parametroEscribir ;
non terminal 			sentenciaEscribir ;

non terminal 			sentencia;
non terminal 			sentenciaFuncion;
non terminal 			listaSentencias;
non terminal 			listaSentenciasFuncion;
non terminal 			sentenciaif;
non terminal 			sentenciaifFuncion;
non terminal 			rellenoif;
non terminal 			rellenoifFuncion;
non terminal 			sentenciafor;
non terminal 			sentenciaforFuncion;
non terminal 			sentenciaDevolver;


non terminal			parametroasignacion;

non terminal			sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA, PRODUCTO;	
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= 
	{:
		System.out.println("Iniciando análisis programa principal");
		scopeManager.openScope("Principal");
	:} 
	defprincipal;

epsilon ::=;

//Definición de constantes
defconstantes ::=   
	IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS defconstantes
	{:
		System.out.println("Empezando a analizar línea de constante");
		//Obtengo el escope y la tabla de simbolos y de tipòs.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		TypeTableIF tyTable = scope.getTypeTable();
		TypeIF tipe;
		//Obtengo el nombre de la constante.
		String nombre_constante = ((TokenIF) id).getLexema();
		//Dependiendo de si es entera o lógica añado la constante a la tabla de simbolos.
		if(valor instanceof PrimitivaAritmetica){
			if(syTable.containsSymbol(nombre_constante)){
				throw new RuntimeException("Ya existe una constante en este ámbito con el mismo nombre: " + nombre_constante);
			}
			//Compruebo que el tipo haya sido creado con anterioridad, en caso contrario lo creo y lo instancio.
			if(!scope.getScopeManager().containsType("entero")){
				tipe = new TypeSimple(scope, "entero");
				tyTable.addType(tipe);
			} else {
				//En caso contrario lo obtengo de la propia tabla de tipos.
				tipe = tyTable.getType("entero");
			}	
			SymbolConstant constante = new SymbolConstant(scope, nombre_constante, tipe);
			syTable.addSymbol(nombre_constante, constante);
		} else if (valor instanceof PrimitivaLogica){
			if(syTable.containsSymbol(nombre_constante)){
				throw new RuntimeException("Ya existe una constante en este ámbito con el mismo nombre: " + nombre_constante);
			}
			//Compruebo que el tipo haya sido creado con anterioridad, en caso contrario lo creo y lo instancio.
			if(!scope.getScopeManager().containsType("boolean")){
				tipe = new TypeSimple(scope, "boolean");
				tyTable.addType(tipe);
			} else {
				//En caso contrario lo obtengo de la propia tabla de tipos.
				tipe = tyTable.getType("boolean");
			}	
			SymbolConstant constante = new SymbolConstant(scope, nombre_constante, tipe);
			syTable.addSymbol(nombre_constante, constante);
		} else
			throw new RuntimeException("Las constantes sólo pueden ser enteras o lógicas");
	:}
	| epsilon; 
valorconstante ::=   
	FALSO 
	{:
		System.out.println("Analizando declaración de constante lógica falsa");
		PrimitivaLogica primitiva = new PrimitivaLogica(null, null, null);
		RESULT= primitiva;
	:}
	| CIERTO 
	{:
		System.out.println("Analizando declaración de constante lógica cierta");
		PrimitivaLogica primitiva = new PrimitivaLogica(null, null, null);
		RESULT= primitiva;
	:}
	| NUM 
	{:
		System.out.println("Analizando declaración de constante aritmética");
		PrimitivaAritmetica primitiva = new PrimitivaAritmetica(null,null,null);
		RESULT= primitiva;
	:};
seccionconstantes ::= 
	BCONSTANTES defconstantes
	{:System.out.println("Sección de constantes analizada");:}
	| epsilon;

 //Definición de tipos
deftipos ::=
	IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:rango_inf RANGO valorango:rango_sup CDERECHO ASIGNACIONVECTOR tipovector:tipo  DSENTENCIAS deftipos
	{:
		System.out.println("Empezando a analizar línea de tipos");
		//Obtengo el escope y la tabla de simbolos y de tipòs.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		TypeTableIF tyTable = scope.getTypeTable();
		TypeIF tipe;
		//Obtengo el nombre del identificador del tipo.
		String nombre_tipo = ((TokenIF) id).getLexema();
		//Copmpruebo que no exista ya un tipo con este nombre.
		if(scope.getScopeManager().containsType(nombre_tipo)){
			throw new RuntimeException("Ya existe un tipo de usuario creado con el nombre: " + nombre_tipo);
		}
		//Obtengo tipo simple que forma parte del compuesto del usuario.
		if(!scope.getScopeManager().containsType((String) tipo)){
			if(tipo.equals("entero")){
				tipe = new TypeSimple(scope, "entero");
				tyTable.addType(tipe);
			} else if(tipo.equals("boolean")){
				tipe = new TypeSimple(scope, "boolean");
				tyTable.addType(tipe);
			} else {
				throw new RuntimeException("Los tipos compuestos sólo pueden estar formados por tipos enteros o lógicos");
			}
		} else {
			tipe = tyTable.getType((String) tipo);
		}
		//Calculo el rango del tipo declarado
		int rango = (int) rango_sup - (int) rango_inf;
		//Instancio el  nuevo tipo y lo añado a la tabla de tipos.
		TypeArray tipo_usuario = new TypeArray(scope, nombre_tipo);
		//Seteo el rango del tipo añadido y de su tipo base.
		tipo_usuario.setRango(rango);
		tipo_usuario.setTypeSimple(tipe);
		tyTable.addType(tipo_usuario);
		System.out.println("Vector de tipo " + nombre_tipo + " de rango " + rango + " de tipo simple " + tipe.getName());
	:} 
	| epsilon;
tipovector ::=
	BOOLEANO
	{:
		System.out.println("Analizando declaración de vector de booleanos");
		RESULT = "boolean";
	:} 
	| ENTERO
	{:
		System.out.println("Analizando declaración de vector de enteros");
		RESULT = "entero";
	:};
valorango ::= 
	NUM:num
	{:
		//Tengo que obtener el numero del valor para pasarselo para calcular el rango del tipo.
		int valor = Integer.parseInt(((TokenIF) num).getLexema());
		RESULT = valor;
	:} 
	| IDEN:id
	{:
		//Tengo que obtener el valor del identificador para pasarselo para calcular el rango del tipo.
		//Obtengo la scope y tabla de símbolos.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String nombre_rango = ((TokenIF) id).getLexema();
		//Compruebo que el identificador exista con anterioridad.
		if(!scopeManager.containsSymbol(nombre_rango)){
			throw new RuntimeException("No se puede establecer el rango debido a que no ha sido declarado con anterioridad el simbolo: " + nombre_rango);
		}
		//Obtengo el símbolo.
		SymbolIF rango = scopeManager.searchSymbol(nombre_rango);
		int valor;
		//Compruevo que el simbolo sea de tipo aritmético.
		if(!rango.getType().getName().equals("entero")){
			throw new RuntimeException("Sólo se pueden establecer rangos con simbolos enteros, actualmente es: " + rango.getType().getName());
		}
		//Compruebo que tenga valor asociado.
		if(rango instanceof SymbolVariable){
			if(((SymbolVariable) rango).getValue() == null){
				throw new RuntimeException("Aunque el simbolo " + nombre_rango + " entero está declarado con anterioridad, aún no se le ha asignado un valor, actualmente es null, no se puede crear un rango de dimensión null");
			}
			//Obtengo el valor del simbolo entero obtenido.
			valor = Integer.parseInt(((SymbolVariable) rango).getValue());
		} else if(rango instanceof SymbolConstant) {
			if(((SymbolConstant) rango).getValue() == null){
				throw new RuntimeException("Aunque el simbolo " + nombre_rango + " entero está declarado con anterioridad, aún no se le ha asignado un valor, actualmente es null, no se puede crear un rango de dimensión null");
			}
			valor = Integer.parseInt(((SymbolConstant) rango).getValue());
		} else {
			throw new RuntimeException("En este punto sólo se espera un símboloo variable o constante, no de otro tipo");
		}
		RESULT = valor;
	:} 
	| miembrovector:mv
	{:
		//Miembro vector devuelve una primitiva aritmetica o logica, solo si es entera obtengo su valor y lo devuelvo.
		if(mv instanceof PrimitivaAritmetica) {
			//int valor_miembro = ((PrimitivaAritmetica) mv).getValor();
			//if( valor_miembro != null){
			RESULT = mv;
			//} else {
				//throw new RuntimeException("El valor del miembro del vector no está inicialiado todavía, es null.");
			//}
		} else
			throw new RuntimeException("Sólo se pueden instanciar rangos con enteros, actualmente la expresión vectorial es: " + mv.getClass().getSimpleName());
		
	:};
secciontipos ::= COMIENZODECLTIPOS deftipos {:System.out.println("Sección de tipos analizada");:} | epsilon; 

// Definición de variables
tipovariable ::= 
	BOOLEANO
	{:
		RESULT = "boolean";
	:} 
	| ENTERO 
	{:
		RESULT = "entero";
	:}
	| IDEN:id
	{:
		RESULT = ((TokenIF) id).getLexema();
	:};
selectorvalororeferencia ::=  
	IDEN:id
	{:
		System.out.println("Obteniedno lexema de declaración de variable: " + ((TokenIF) id).getLexema());
		String lexema = ((TokenIF) id).getLexema();
		//Creo el parámetro.
		Parametro parametro = new Parametro(lexema, false);
		RESULT = parametro;
	:}
	|	PARAMETROVALOR IDEN:id
	{:
		System.out.println("Obteniedno lexema de declaración de variable: " + ((TokenIF) id).getLexema());
		String lexema = ((TokenIF) id).getLexema();
		//Creo el parámetro.
		Parametro parametro = new Parametro(lexema, true);
		RESULT = parametro;
	:};	
listavariables ::= 
	selectorvalororeferencia:parametro {:
		//He utilizado un métoido estático para poder ir añadiendo elementos.
		ListaVariables.addVariable((Parametro) parametro);
		System.out.println("Declaración de variable analizada:" + ((Parametro) parametro).getNombre());
	:} DIDENTIFICADORES listavariables
	| selectorvalororeferencia:parametro
	{:
		ListaVariables.addVariable((Parametro) parametro);
		System.out.println("Última declaración de variable analizada de la línea:" + ((Parametro) parametro).getNombre());
	:}
	| epsilon;
defvariables ::= 
	{:
		System.out.println("Iniciando análisis de declaración de variables");
		//Limpio la lista de variables de la línea anterior.
		ListaVariables.clearVariables();
	:} 
	listavariables:lista DELIMFUNC tipovariable:tipo puntoycomaopcional {:
		System.out.println("Analizando una línea de declaración de variables");
		//Obtengo el escope y la tabla de simbolos y de tipòs.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		TypeTableIF tyTable = scope.getTypeTable();
		//Obtengo los nombres de las variables en declaración en esta línea.
		ArrayList<Parametro> parametros = ListaVariables.getVariables();
		//Según el nombre del tipo guardo el tipo.
		TypeIF tipe;
		boolean vector = false;
		switch((String) tipo){
			case "entero":
				//En el caso de que el tipo no se haya declarado antes, lo añado a la tabla de tipos.
				if(!scope.getScopeManager().containsType("entero")){
					tipe = new TypeSimple(scope, "entero");
					tyTable.addType(tipe);
				} else {
					//En caso contrario lo obtengo de la propia tabla de tipos.
					tipe = scopeManager.searchType("entero");
				}				
				break;
			case "boolean":
				if(!scope.getScopeManager().containsType("boolean")){
					tipe = new TypeSimple(scope, "boolean");
					tyTable.addType(tipe);
				} else {
					tipe = scopeManager.searchType("boolean");
				}
				break;
			default:
				if(!scope.getScopeManager().containsType((String) tipo)){
					throw new RuntimeException("No se puede declarar variables con tipos de usuario no declarados anteriormente, declara el tipo antes de usarlo: " + (String) tipo);
				} else {
					tipe = scopeManager.searchType((String) tipo);
					vector = true;
				}
				break;
		}
		//Creo un símbolo para cada una de ellas según su tipo y nombre y la añado a la tabla de símbolos.
		for(Parametro parametro : parametros){
			String nombre_variable = parametro.getNombre();
			if(syTable.containsSymbol(nombre_variable)){
				throw new RuntimeException("Ya existe una variable en este ámbito con el mismo nombre: " + nombre_variable);
			}
			SymbolVariable variable = new SymbolVariable(scope, nombre_variable, tipe);
			//Si la variable declarada ha tenido un var precediendole entonces es por referencia y le seteo dicha información.
			if(parametro.getValVSRef() || vector){
				variable.setValVSRef(true);			
			}
			System.out.println("Variable declarada con nombre " + nombre_variable + " y tipo " + tipe.getName());
			syTable.addSymbol(nombre_variable, variable);
		}
	:} defvariables 
	| epsilon; 

seccionvariables ::= DECLVARIABLES defvariables | epsilon;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

//reglas de subprogramas
tiporetornofuncion ::= 
	IDEN:id 
	{:	
		String nombre_tipo = ((TokenIF) id).getLexema();
		//Compruebo que el tipo ya haya sido declarado en la scope, sino, lanzo error.
		if(!scopeManager.containsType(nombre_tipo)){
			throw new RuntimeException("No se puede crear una función con un tipo de retorno no declarado, declare el tipo: " + nombre_tipo);
		}
		RESULT = nombre_tipo;
	:} 
	| tipovector:entvsbool
	{:
		//Aquí se está decidiendo si se el tipo es entero o booleano aunque no lo parezca.
		//Simplemento lo devuelvo (es String)
		RESULT = entvsbool;	
	:};
procedimiento ::= 
	COMIENZOPROCEDIMIENTO IDEN:id
	{:
		String nombre_procedimiento = ((TokenIF) id).getLexema();

		//Guardo el procedimiento en el scope actual.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		SymbolProcedure procedimiento = new SymbolProcedure(scope, nombre_procedimiento, null);
		syTable.addSymbol(procedimiento);

		//Creo un scope nuevo para añadir la información del procedimiento.
		scopeManager.openScope(nombre_procedimiento);
		System.out.println("Empezando a analizar procedimiento: " + nombre_procedimiento);
	:}
	PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias  FINBLOQUESENTENCIAS DSENTENCIAS 
	{:
		System.out.println("Procedimiento analizado correctamente");
		scopeManager.closeScope();
	:};
funcion ::= DECLAREFUNCION IDEN:id
	{:
		//Abro una nueva scope para añadir la información de la función.
		String nombre_funcion = ((TokenIF) id).getLexema();
		scopeManager.openScope(nombre_funcion);
		System.out.println("Empezando a analizar funcion: " + nombre_funcion);
		
	:} 
	PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion:retorno 
	{:
		//Busco la scope del programa que lo engloba (la scope padre) y añado la función a su tabla de símbolos.
		ScopeIF scope = scopeManager.getParentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		SymbolFunction funcion = new SymbolFunction(scope, ((TokenIF) id).getLexema(), (TypeIF) scopeManager.searchType((String) retorno));
		syTable.addSymbol(funcion);	
		
	:}
	DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS
	{:
		//Obtengo el devolver declarado en la función.
		//Compruebo que se ha producido un devolver correcto.
		if(!SymbolFunction.getDevolverDeclarado()){
			throw new RuntimeException("No se ha explicitado un devolver en la función: " + ((TokenIF) id).getLexema());
		} else if(!SymbolFunction.comprobarTiposDevolver((String) retorno)){
			SymbolFunction.clearTiposDevolver();
			throw new RuntimeException("Al menos un tipo devolver explicitado en la función " + ((TokenIF) id).getLexema() + " no es del tipo declarado: " + (String) retorno);
		} else
			//Reseteo los tipos devolver para futuras funciones.
			SymbolFunction.clearTiposDevolver();

		//Lo seteo a false para comprobar siguientes funciones.
		SymbolFunction.setDevolverDeclarado(false);

		System.out.println("Función analizada correctamente");
		scopeManager.closeScope();
	:};
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  
	{:
		System.out.println("Iniciando análisis de subprogramas");
	:}
	defsubprograma  | epsilon ;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA 
	{:
		scopeManager.closeScope();
	:};

expresion ::=  
	expresion:vi MENORQUE  expresion:vd
	{:
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			ExpresionLogica logica = new ExpresionLogica((Expresion) vi, "<",(Expresion) vd);
			RESULT= logica;
		}
		else
			throw new RuntimeException("No se puedem mezclar tipos de expresiones: " + ((Expresion) vi).getClass().getSimpleName() + " con " + ((Expresion) vd).getClass().getSimpleName());
	:}
	|  expresion:vi IGUALDAD  expresion:vd
		{:
		System.out.println("Analizando parte de expresión");
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			ExpresionLogica logica = new ExpresionLogica((Expresion) vi, "==",(Expresion) vd);
			RESULT= logica;
		}
		else
			throw new RuntimeException("No se puedem mezclar tipos de expresiones: " + ((Expresion) vi).getClass().getSimpleName() + " con " + ((Expresion) vd).getClass().getSimpleName());
	:}
	| IDEN:id
	{:
		System.out.println("Extrayendo identificador de parte de una expresión");
		//Hay que obtener el símbolo relacionado a IDEN
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = ((TokenIF) id).getLexema();
		SymbolIF identificador;
		//Compruebo y obtengo el sombolo del identificador.
		if(scopeManager.containsSymbol(lexema)){
			identificador = scopeManager.searchSymbol(((TokenIF) id).getLexema());
		}
		else
			throw new RuntimeException("No existe ningún símbolo con nombre " + lexema);
		//Ahora hay que determinar qué tipo de símbolo es, según el tipo habrá que ver si es compatible con ser parte de una expresión.
		Expresion primitiva;
		switch(identificador.getClass().getSimpleName()){
			case "SymbolConstant":
				if(identificador.getType().getName().equals("entero")){
					//Creo la primitiva en el caso de que el tipo de la constante sea entera.
					primitiva = new PrimitivaAritmetica(null,null,null);
					//primitiva.setValor(Integer.parseInt(identificador.getValue()));
					RESULT = primitiva;
				}
				else if(identificador.getType().getName().equals("boolean")){
					//HAY QUE IMPLEMENTAR getValue() en simbolos constantes.
					primitiva = new PrimitivaLogica(null,null,null);
					//primitiva.setValorLogico(Boolean.valueOf(identificador.getValue()));
					RESULT = primitiva;
				}
				else
					throw new RuntimeException("No se puede utilizar una constante de tipo " + identificador.getType().getName() + " como parte de una expresión aritmética o lógica, sólo está permitido enteros.");
				break;
			case "SymbolParameter":
				//TODO hasta que tenga aclarado qué es este tipo de símbolo
				break;
			case "SymbolVariable":
				if(identificador.getType().getName().equals("entero")){
					//Creo la primitiva en el caso de que el tipo de la constante sea entera.
					//Creo la primitiva en el caso de que el tipo de la constante sea entera.
					primitiva = new PrimitivaAritmetica(null,null,null); 
					//primitiva.setValor(Integer.parseInt(identificador.getValue()));
					RESULT = primitiva;
				}
				else if(identificador.getType().getName().equals("boolean")){
					//HAY QUE IMPLEMENTAR getValue() en simbolos variables.
					primitiva = new PrimitivaLogica(null,null,null);
					//primitiva.setValorLogico(Boolean.valueOf(identificador.getValue()));
					RESULT = primitiva;
				} 
				else
					throw new RuntimeException("No se puede utilizar una constante de tipo " + identificador.getType().getName() + " como parte de una expresión aritmética o lógica, sólo está permitido enteros o primitivas lógicas.");
				break;
			default:
				throw new RuntimeException("No se puede utilizar un símbolo de tipo " + identificador.getClass().getSimpleName() + " como parte de una expresión.");
		}			
	:}
	| llamadafuncion:f
	{:
		//Hay que obtener la función relacionada a llamadafuncion
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = ((TokenIF) f).getLexema();
		//Compruebo que no es un procedimiento pues no puede ser parte de una expresión.
		if(f instanceof SymbolProcedure){
			throw new RuntimeException("No está permitido el uso de procedimientos como parte de una expresión.");
		}
		SymbolFunction funcion;
		//Compruebo y obtengo la función de la tabla de símbolos.
		if(scopeManager.containsSymbol(lexema)){
			funcion = (SymbolFunction) scopeManager.searchSymbol(lexema);
		}
		else
			throw new RuntimeException("No existe ninguna función con nombre " + lexema);
		Expresion primitiva;
		//Según el tipo de la función creo un tipo de expresión u otra.
		switch(funcion.getReturn().getName()){
			case "entero":
				//Creo una PrimitivaAritmetica.
				primitiva = new PrimitivaAritmetica(null,null,null);
				//primitiva.setValor(Integer.parseInt(funcion.getValue()));
				RESULT = primitiva;
				break;
			case "boolean": 
				//Creo una PrimitivaLogica
				primitiva = new PrimitivaLogica(null,null,null);
				//primitiva.setValorLogico(Boolean.valueOf(funcion.getValue()));
				RESULT = primitiva;
				break;
			default:
				throw new RuntimeException("Las funciones con este tipo de retorno " + funcion.getType().getName() + " no pueden formar parte de una expresión.");		
		}
	:}
	| CIERTO 
	{:
		//Creo una primitiva lógica y le seteo su valor true.
		PrimitivaLogica primitiva_logica = new PrimitivaLogica(null,null,null);
		primitiva_logica.setValorLogico(true);
		RESULT = primitiva_logica;
	:}
	| FALSO 
	{:
		//Creo una primitiva lógica y le seteo su valor false.
		PrimitivaLogica primitiva_logica = new PrimitivaLogica(null,null,null);
		primitiva_logica.setValorLogico(false);
		RESULT = primitiva_logica;
	:}
	| miembrovector:v
	{:
		RESULT = v;
	:}
	| NUM:num
	{:
		//Creo la primitiva, le seteo su valor y la devuelvo.
		PrimitivaAritmetica numero = new PrimitivaAritmetica(null, null, null);
		numero.setValor(Integer.parseInt(((TokenIF) num).getLexema()));
		RESULT = numero;
	:}
	| expresionlvl2:lvl2
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl2;
	:};
expresionlvl2 ::=  
	expresion:vi SUMA expresion:vd 
	{:  
		//ScopeIF scope = scopeManager.getCurrentScope();
		//SymbolTableIF syTable = scope.getSymbolTable();
		
		//Compruebo que ambas expresiones son o bien aritméticas o bien primitivas aritméticas.
		if(((vi instanceof ExpresionAritmetica) ||(vi instanceof PrimitivaAritmetica)) && ((vd instanceof ExpresionAritmetica) ||	(vd instanceof PrimitivaAritmetica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionAritmetica((Expresion) vi, "+", (Expresion) vd);
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + ((Expresion) vi).getClass().getSimpleName() + " con " + ((Expresion) vd).getClass().getSimpleName());
	:}
	| expresionlvl3:lvl3
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl3;
	:};
expresionlvl3 ::=  
	expresion:vi YLOGICA expresion:vd 
	{:
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			ExpresionLogica logica = new ExpresionLogica((Expresion) vi, "&&", (Expresion) vd);
			RESULT= logica;
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + ((Expresion) vi).getClass().getSimpleName() + " con " + ((Expresion) vd).getClass().getSimpleName());
	:}
	| expresion:vi PRODUCTO expresion:vd 
	{:  
		//ScopeIF scope = scopeManager.getCurrentScope();
		//SymbolTableIF syTable = scope.getSymbolTable();
		if(((vi instanceof ExpresionAritmetica) ||(vi instanceof PrimitivaAritmetica)) && ((vd instanceof ExpresionAritmetica) ||	(vd instanceof PrimitivaAritmetica))){
			//En dicho caso creo la expresión aritmética.
			ExpresionAritmetica logica = new ExpresionAritmetica((Expresion) vi, "+", (Expresion) vd);
			RESULT= logica;
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + ((Expresion) vi).getClass().getSimpleName() + " con " + ((Expresion) vd).getClass().getSimpleName());
	:}
	| expresionlvl4:lvl4
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl4;
	:};
expresionlvl4 ::= 
	NOLOGICO  expresion:vd 
	{:
		//Compruebo que la expresión sea bien lógica o bien primitiva lógica.
		if((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica)){
			//En dicho caso creo la expresión aritmética.
			ExpresionLogica logica = new ExpresionLogica(null, "!", (Expresion) vd);
			RESULT= logica;
		}
		else
			throw new RuntimeException("Una expresión de tipo " + ( (Expresion) vd).getClass().getSimpleName() + " no puede ser parte de una expresión lógica de negación.");
	:}
	| expresionlvl5:lvl5 
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl5;
	:};
expresionlvl5 ::= 
	PIZQUIERDO expresion:va PDERECHO
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = va;
	:}
	| CIZQUIERDO expresion:va CDERECHO 
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = va;
	:};

// Acceso a vectores
miembrovector::= IDEN:id CIZQUIERDO valorango:rango CDERECHO
	{:
		//Hay que obtener el vector relacionado con miembroVector
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String nombre_vector = ((TokenIF) id).getLexema();
		SymbolIF vector; 
		TypeArray tipo_array;
		if(scopeManager.containsSymbol(nombre_vector) && (scopeManager.searchSymbol(nombre_vector).getType() instanceof TypeArray)){
			vector = scopeManager.searchSymbol(nombre_vector);
			//Compruebo que no se haya pasado de dimensión el rango proporcionado (>=).
			if((int) rango >= ((TypeArray) vector.getType()).getRango()){
				throw new RuntimeException("Intento de acceso al array " + nombre_vector + " fuera de rango, su tamaño es " + ((TypeArray) vector.getType())
.getRango() + " y se trata de acceder al miembro " + (int) rango);
			}
			tipo_array = (TypeArray) scopeManager.searchSymbol(nombre_vector).getType();
		} else
			throw new RuntimeException("No se ha encontrado un vector con el nombre: " + nombre_vector);		
		//Según el tipo del vector creo un tipo de expresión u otra. TODO IMPLEMENTACION getName() en TypeArray.
		Expresion primitiva;
		
		switch(tipo_array.getTypeSimple().getName()){
			case "entero":
				//Creo una PrimitivaAritmetica.
				primitiva = new PrimitivaAritmetica(null,null,null);
				//int valor_miembro = ((int) vector.getArray()[(int) rango]);
				//primitiva.setValor(valor_miembro);
				((PrimitivaAritmetica) primitiva).setNombreVector(nombre_vector);
				RESULT = primitiva;
				break;
			case "boolean": 
				primitiva = new PrimitivaLogica(null,null,null);
				//boolean valor_miembro = ((boolean) vector.getArray()[(int) rango]);
				//primitiva.setValorLogico(valor_miembro);
				((PrimitivaLogica) primitiva).setNombreVector(nombre_vector);
				RESULT = primitiva;
				break;
			default:
				throw new RuntimeException("Los vectores solo pueden estar conformados de enteros o lógicos, actualmente: " + tipo_array.getTypeSimple());
		}		
	:};
 
// sentencias de asignacion
parteizquierdaasignacion ::= 
	IDEN:id
	{:
		System.out.println("Obteniendo parte izquierda de asignación");
		//Hay que obtener el símbolo relacionado a IDEN
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = ((TokenIF) id).getLexema();
		SymbolIF identificador;
		//Compruebo y obtengo el sombolo del identificador.
		if(scopeManager.containsSymbol(lexema)){
			identificador = scopeManager.searchSymbol(((TokenIF) id).getLexema());
			System.out.println(identificador);
			System.out.println("Variable encontrada en la tabla de símbolos de tipo: " + identificador.getType().getName());
			//Si es una contante lo que hay en la parte izquierda; no está permitido. 
			if(identificador instanceof SymbolConstant){
				throw new RuntimeException("No se puede realizar una asignación de una constante");
			}
		}
		else
			throw new RuntimeException("No existe ningún símbolo con nombre " + lexema);
		//Compruebo si el identificador corresponde a una variable.
		if(identificador.getClass().getSimpleName().equals("SymbolVariable")){
			RESULT = identificador;
		} else
			throw new RuntimeException("No se puede utilizar en una sentencia de asignación un símbolo de tipo: " + identificador.getClass().getName());
	:} 
	| miembrovector:mv
	{:
		System.out.println("Obteniendo parte vectorial izquierda de asignación");
		//Obtengo el simbolo del array del que forma parte el miembro.
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema;
		//Obtengo el nombre del vector
		if(mv instanceof PrimitivaAritmetica){
			lexema = ((PrimitivaAritmetica) mv).getNombreVector();
		} else if (mv instanceof PrimitivaLogica){
			lexema = ((PrimitivaLogica) mv).getNombreVector();
		} else {
			throw new RuntimeException("En este punto sólo se espera la llegada de una primitiva aritmética o lógica");
		}
		SymbolIF vector;
		if(scopeManager.containsSymbol(lexema)){
			vector = scopeManager.searchSymbol(lexema);
		}
		else
			throw new RuntimeException("No existe ningún símbolo con nombre " + lexema);
		RESULT = vector;
	:};
sentenciadeasignacion ::= parteizquierdaasignacion:pi ASIGNACION parametroasignacion:pd DSENTENCIAS
	{:
		System.out.println("Empezando a analizar asignación");
		System.out.println("El tipo de la expresión derecha es: " + ((Expresion) pd).getType());
		//Compruebo si concuerdan los tipos de la parte izquierda y derecha y qué tipòs son, según sea seteo la SentenciaAsignacion.
		if(( ((SymbolIF) pi).getType().getName().equals("entero") && ((Expresion) pd).getType().equals("entero"))){
			SentenciaAsignacion asign = new SentenciaAsignacion((SymbolIF) pi, (Expresion) pd, "entero");
			System.out.println("Sentencia de asignación entera analizada");
			RESULT = asign;
		} else if(((SymbolIF) pi).getType().getName().equals("boolean") && ((Expresion) pd).getType().equals("boolean")){
			SentenciaAsignacion asign = new SentenciaAsignacion((SymbolIF) pi,(Expresion) pd,"boolean");
			System.out.println("Sentencia de asignación booleana analizada");
			RESULT = asign;
		//En el caso de miembros de vectores la cosa se complica un poco, compruebo que primero sea un array y luego que su tiempo simple sea igual a la expresión de la derecha.
		} else if((((SymbolIF) pi).getType() instanceof TypeArray) && ((TypeArray) ((SymbolIF) pi).getType()).getTypeSimple().getName().equals(((Expresion) pd).getType())) {
			SentenciaAsignacion asign = new SentenciaAsignacion((SymbolIF) pi, (Expresion) pd,"miembro_vector");
			System.out.println("Sentencia de asignación a miembro de vector añadida");
		} else
			//System.out.println(((SymbolIF) pi).getType().getName() + "     tiposimple" + ((TypeArray) ((SymbolIF) pi).getType()).getTypeSimple().getName);
			throw new RuntimeException("No se puede asignar a una variable de tipo " + ((SymbolIF) pi).getType().getName() + " una expresión de tipo " + ((Expresion) pd).getType());
	:}; 
parametroasignacion ::= expresion:ex
	{:
		System.out.println("Obteniendo expresión de sentencia de asignación");
		RESULT = ex;
	:};


// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion ;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

// llamada a función
parametrofuncionoproc ::=     listavariables ;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon ;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;


// escribir. 
parametroEscribir ::= STRING | expresion | epsilon ;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

// devolver
sentenciaDevolver ::= 
	FRETURN expresion:exp DSENTENCIAS
	{:
		//¿¿HAY QUE ASEGURARSE QUE SE VAYA A EJECUTAR UN DEVOLVER EN CADA IF,ETC??
		String tipo = ((Expresion) exp).getType();
		System.out.println("LLegada a sentencia devolver de tipo: " + ((Expresion) exp).getType());
		SymbolFunction.addTipoDevolver(tipo);
		SymbolFunction.setDevolverDeclarado(true);
	:};



