package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  			program;
non terminal Axiom		axiom;
non terminal  			epsilon;
non terminal  			defconstantes;
non terminal  			valorconstante;
non terminal  			seccionconstantes;
non terminal  			deftipos;
non terminal  			tipovector;
non terminal  			valorango;
non terminal  			secciontipos;
non terminal  			defvariables;
non terminal			tipovariable;
non terminal  			listavariables;
non terminal  			seccionvariables;
non terminal  			defsubprograma;
non terminal			puntoycomaopcional;

non terminal 			tiporetornofuncion;
non terminal  			seccionsubprograma;
non terminal  			defprincipal;
non terminal			selectorvalororeferencia;


non terminal			expresion;
non terminal			expresionlvl2;
non terminal			expresionlvl3;
non terminal			expresionlvl4;
non terminal			expresionlvl5;




non terminal			miembrovector;
non terminal			procedimiento;
non terminal			funcion;
non terminal			selectorpof;

non terminal            parametrofuncionoproc;
non terminal 			llamadafuncion ; 

non terminal 			parteizquierdaasignacion;  
non terminal 			sentenciadeasignacion;

non terminal 			parametroEscribir ;
non terminal 			sentenciaEscribir ;

non terminal 			sentencia;
non terminal 			sentenciaFuncion;
non terminal 			listaSentencias;
non terminal 			listaSentenciasFuncion;
non terminal 			sentenciaif;
non terminal 			sentenciaifFuncion;
non terminal 			rellenoif;
non terminal 			rellenoifFuncion;
non terminal 			sentenciafor;
non terminal 			sentenciaforFuncion;
non terminal 			sentenciaDevolver;


non terminal			parametroasignacion;

non terminal			sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA, PRODUCTO;	
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= 
	{:
		ScopeManager.openScope("Principal");
	:} 
	defprincipal;

epsilon ::=;

//Definición de constantes
defconstantes ::=   IDEN ASIGNACION valorconstante DSENTENCIAS defconstantes | epsilon; 
valorconstante ::=   FALSO | CIERTO | NUM ;
seccionconstantes ::= BCONSTANTES defconstantes | epsilon;

 //Definición de tipos
deftipos ::=IDEN ASIGNACION DECLVECTOR CIZQUIERDO valorango RANGO valorango CDERECHO ASIGNACIONVECTOR tipovector  DSENTENCIAS deftipos | epsilon;
tipovector ::=BOOLEANO | ENTERO ;
valorango ::= NUM | IDEN | miembrovector;
secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

// Definición de variables
tipovariable ::= 
	BOOLEANO
	{:
		RESULT = "boolean";
	:} 
	| ENTERO 
	{:
		RESULT = "entero";
	:}
	| IDEN 
	{:
		RESULT = "vector";
	:};
selectorvalororeferencia ::=  
	PARAMETROVALOR IDEN:id
	{:
		String lexema = id.getLexema();
		RESULT = lexema;
	:} 
	|	expresion;
defvariables ::= 
	{:
		//Limpio la lista de variables de la línea anterior.
		ListaVariables.clearVariables();
	:} 
	listavariables:lista DELIMFUNC tipovariable:tipo puntoycomaopcional {:
		//Obtengo el escope y la tabla de simbolos y de tipòs.
		ScopeIf scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		TypeTableIF tyTable = scope.getTypeTable();
		//Obtengo los nombres de las variables en declaración en esta línea.
		ArrayList<String> nombre_variables = ListaVariables.getVariables();
		//Según el nombre del tipo guardo el tipo.
		TypeBase tipe;
		switch(tipo){
			case "entero":
				//Hay que implementar que en TypeSimple se guarde el tipo nominal según lo indicado por el constructor.
				tipe = new TypeSimple("entero");
				//En el caso de que el tipo no se haya declarado antes, lo añado a la tabla de tipos.
				if(!scope.containsType(scope, "entero")){
					tyTable.addType(tipe);
				}				
				break;
			case "boolean":
				tipe = new TypeSimple("boolean");
				if(!scope.containsType(scope, "boolean")){
					tyTable.addType(tipe);
				}		
				break;
			case "vector":
				//¿Donde indicar el tamaño del vector?
				tipe = new TypeArray();
				if(!scope.containsType(scope, "vector")){
					tyTable.addType(tipe);
				}		
				break;
			default:
				throw new RuntimeException("No se puede declarar una variable del tipo: " + tipo);
		}
		//Creo un símbolo para cada una de ellas según su tipo y nombre y la añado a la tabla de símbolos.
		for(String nombre_variable : nombre_variables){
			if(syTable.containsSymbol(nombre_variable)){
				throw new RuntimeException("Ya existe una variable en este ámbito con el mismo nombre: " + nombre_variable);
			}
			SymbolVariable variable = new SymbolVariable(scope, nombre_variable, tipe);
			syTable.addSymbol(nombre_variable, variable);
		}
	:} defvariables 
	| epsilon; 
listavariables ::= 
	selectorvalororeferencia:lex DIDENTIFICADORES listavariables:lista
	{:
		//He utilizado un métoido estático para poder ir añadiendo elementos.
		ListaVariables.addVariable(lex);
	:} 
	| selectorvalororeferencia:lex
	{:
		ListaVariables.addVariable(lex);
	:}
	| epsilon;
seccionvariables ::= DECLVARIABLES defvariables | epsilon  ;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

//reglas de subprogramas
tiporetornofuncion ::= IDEN | tipovector ;
procedimiento ::= COMIENZOPROCEDIMIENTO IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias   FINBLOQUESENTENCIAS DSENTENCIAS ;
funcion ::= DECLAREFUNCION IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS  ;
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA ;

expresion ::=  
	expresion:vi MENORQUE  expresion:vd
	{:
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionLogica(vi, "<", vd);
		}
		else
			throw new RuntimeException("No se puedem mezclar tipos de expresiones: " + vi.getClass().getSimpleName() + " con " + vd.getClass().getSimpleName());
	:}
	|  expresion:vi IGUALDAD  expresion:vd
		{:
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionLogica(vi, "==", vd);
		}
		else
			throw new RuntimeException("No se puedem mezclar tipos de expresiones: " + vi.getClass().getSimpleName() + " con " + vd.getClass().getSimpleName());
	:}
	| IDEN:id
	{:
		//Hay que obtener el símbolo relacionado a IDEN
		ScopeIf scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = id.getLexema();
		//Compruebo y obtengo el sombolo del identificador.
		if(syTable.containsSymbol(lexema)){
			SymbolBase identificador = syTable.getSymbol(id.getLexema());
		}
		else
			throw new RuntimeException("No existe ningún símbolo con nombre " + lexema);
		//Ahora hay que determinar qué tipo de símbolo es, según el tipo habrá que ver si es compatible con ser parte de una expresión.
		switch(identificador.getClass().getSimpleName()){
			case "SymbolConstant":
				if(identificador.getType().getName().equals("entero")){
					//Creo la primitiva en el caso de que el tipo de la constante sea entera.
					PrimitivaAritmetica primitiva = new PrimitivaAritmetica(null,null,null);
					primitiva.setValor(Integer.parseInt(identificador.getValue()));
					RESULT = primitiva;
				}
				else if(identificador.getType().getName().equals("boolean")){
					//HAY QUE IMPLEMENTAR getValue() en simbolos constantes.
					PrimitivaLogica primitiva = new PrimitivaLogica(null,null,null);
					primitiva.setValorLogico(Boolean.valueOf(identificador.getValue()));
					RESULT = primitiva;
				}
				else
					throw new RuntimeException("No se puede utilizar una constante de tipo " + identificador.getType().getName() + " como parte de una expresión aritmética o lógica, sólo está permitido enteros.");
				break;
			case "SymbolParameter":
				//TODO hasta que tenga aclarado qué es este tipo de símbolo
				break;
			case "SymbolVariable":
				if(identificador.getType().getName().equals("entero")){
					//Creo la primitiva en el caso de que el tipo de la constante sea entera. 
					primitiva.setValor(Integer.parseInt(identificador.getValue()));
					RESULT = primitiva;
				}
				else if(identificador.getType().getName().equals("boolean")){
					//HAY QUE IMPLEMENTAR getValue() en simbolos variables.
					PrimitivaLogica primitiva = new PrimitivaLogica(null,null,null);
					primitiva.setValorLogico(Boolean.valueOf(identificador.getValue()));
					RESULT = primitiva;
				} 
				else
					throw new RuntimeException("No se puede utilizar una constante de tipo " + identificador.getType().getName() + " como parte de una expresión aritmética o lógica, sólo está permitido enteros.");
				break;
			default:
				throw new RuntimeException("No se puede utilizar un símbolo de tipo " + identificador.getClass().getSimpleName() + " como parte de una expresión.");
		}			
	:}
	| llamadafuncion:f
	{:
		//Hay que obtener la función relacionada a llamadafuncion
		ScopeIf scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = f.getLexema();
		//Compruebo y obtengo la función de la tabla de símbolos.
		if(syTable.containsSymbol(lexema)){
			SymbolBase funcion = syTable.getSymbol(lexema);
		}
		else
			throw new RuntimeException("No existe ninguna función con nombre " + lexema);
		//Según el tipo de la función creo un tipo de expresión u otra.
		switch(funcion.getReturn()){
			case "entero":
				//Creo una PrimitivaAritmetica.
				PrimitivaAritmetica primitiva = new PrimitivaAritmetica(null,null,null);
				primitiva.setValor(Integer.parseInt(funcion.getValue()));
				RESULT = primitiva;
				break;
			case "boolean": 
				//Creo una PrimitivaLogica
				PrimitivaLogica primitiva = new PrimitivaLogica(null,null,null);
				primitiva.setValorLogico(Boolean.valueOf(funcion.getValue()));
				RESULT = primitiva;
				break;
			default:
				throw new RuntimeException("Las funciones con tipo de retorno " + funcion.getType().getReturn() + " no pueden formar parte de una expresión.");		
		}
	:}
	| CIERTO 
	{:
		//Creo una primitiva lógica y le seteo su valor true.
		PrimitivaLogica primitiva_logica = new PrimitivaLogica(null,null,null);
		primitiva_logica.setValorLogico(true);
		RESULT = primitiva_logica;
	:}
	| FALSO 
	{:
		//Creo una primitiva lógica y le seteo su valor false.
		PrimitivaLogica primitiva_logica = new PrimitivaLogica(null,null,null);
		primitiva_logica.setValorLogico(false);
		RESULT = primitiva_logica;
	:}
	| miembrovector:v
	{:
		//Hay que obtener el vector relacionado con miembroVector
		ScopeIf scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = v.getLexema();
		//Compruebo y obtengo el vector de la tabla de símbolos.
		if(syTable.containsSymbol(lexema)){
			SymbolBase vector = syTable.getSymbol(lexema);
		}
		else
			throw new RuntimeException("No existe ningún vector con nombre " + lexema);
		//Según el tipo del vector creo un tipo de expresión u otra. TODO IMPLEMENTACION getName() en TypeArray.
		switch(vector.getType().getName()){
			case "entero":
				//Creo una PrimitivaAritmetica.
				PrimitivaAritmetica primitiva = new PrimitivaAritmetica(null,null,null);
				primitiva.setValor(Integer.parseInt(vector.getValue()));
				RESULT = primitiva;
				break;
			case "boolean": 
				PrimitivaLogica primitiva = new PrimitivaLogica(null,null,null);
				primitiva.setValorLogico(Boolean.valueOf(vector.getValue()));
				RESULT = primitiva;
				break;
			default:
				throw new RuntimeException("Los vectores con elementos de tipo " + funcion.getType().getName() + " no pueden formar parte de una expresión.");		
		}
	:}
	| NUM:num
	{:
		//Creo la primitiva, le seteo su valor y la devuelvo.
		PrimitivaAritmetica numero = new PrimitivaAritmetica(null, null, null);
		numero.setValor(Integer.parseInt(num.getLexema()));
		RESULT = numero;
	:}
	| expresionlvl2:lvl2
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl2;
	:};
expresionlvl2 ::=  
	expresion:vi SUMA expresion:vd 
	{:  
		//ScopeIf scope = scopeManager.getCurrentScope();
		//SymbolTableIF syTable = scope.getSymbolTable();
		
		//Compruebo que ambas expresiones son o bien aritméticas o bien primitivas aritméticas.
		if(((vi instanceof ExpresionAritmetica) ||(vi instanceof PrimitivaAritmetica)) && ((vd instanceof ExpresionAritmetica) ||	(vd instanceof PrimitivaAritmetica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionAritmetica(vi, "+", vd);
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + vi.getClass().getSimpleName() + " con " + vd.getClass().getSimpleName());
	:}
	| expresionlvl3:lvl3
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl3;
	:};
expresionlvl3 ::=  
	expresion:vi YLOGICA expresion:vd 
	{:
		//Compruebo que ambas expresiones son o bien lógicas o bien primitivas lógicas.
		if(((vi instanceof ExpresionLogica) ||(vi instanceof PrimitivaLogica)) && ((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionLogica(vi, "&&", vd);
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + vi.getClass().getSimpleName() + " con " + vd.getClass().getSimpleName());
	:}
	| expresion:vi PRODUCTO expresion:vd 
	{:  
		//ScopeIf scope = scopeManager.getCurrentScope();
		//SymbolTableIF syTable = scope.getSymbolTable();
		if(((vi instanceof ExpresionAritmetica) ||(vi instanceof PrimitivaAritmetica)) && ((vd instanceof ExpresionAritmetica) ||	(vd instanceof PrimitivaAritmetica))){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionAritmetica(vi, "+", vd);
		}
		else
			throw new RuntimeException("No se pueden mezclar tipos de expresiones: " + vi.getClass().getSimpleName() + " con " + vd.getClass().getSimpleName());
	:}
	| expresionlvl4:lvl4
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl4;
	:};
expresionlvl4 ::= 
	NOLOGICO  expresion:vd 
	{:
		//Compruebo que la expresión sea bien lógica o bien primitiva lógica.
		if((vd instanceof ExpresionLogica) ||	(vd instanceof PrimitivaLogica)){
			//En dicho caso creo la expresión aritmética.
			RESULT= new ExpresionLogica(null, "!", vd);
		}
		else
			throw new RuntimeException("Una expresión de tipo " + vd.getClass().getSimpleName() + " no puede ser parte de una expresión lógica de negación.");
	:}
	| expresionlvl5:lvl5 
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = lvl5;
	:};
expresionlvl5 ::= 
	PIZQUIERDO expresion:va PDERECHO
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = va;
	:}
	| CIZQUIERDO expresion:va CDERECHO 
	{:
		//Simplemente devuelvo la expresión hasta el momento.
		RESULT = va;
	:};

// Acceso a vectores
miembrovector::= IDEN CIZQUIERDO valorango CDERECHO;
 
// sentencias de asignacion
parteizquierdaasignacion ::= 
	IDEN:id
	{:
		//Hay que obtener el símbolo relacionado a IDEN
		ScopeIf scope = scopeManager.getCurrentScope();
		SymbolTableIF syTable = scope.getSymbolTable();
		String lexema = id.getLexema();
		//Compruebo y obtengo el sombolo del identificador.
		if(syTable.containsSymbol(lexema)){
			SymbolBase identificador = syTable.getSymbol(id.getLexema());
		}
		else
			throw new RuntimeException("No existe ningún símbolo con nombre " + lexema);
		//Compruebo si el identificador corresponde a una variable.
		if(identificador.getClass().getname().equals("SymbolVariable")){
			RESULT = identificador;
		} else
			throw new RuntimeException("No se puede utilizar en una sentencia de asignación un símbolo de tipo: " + identificador.getClass().getName());
	:} 
	| miembrovector:mv
	{:
		RESULT = mv;
	:};
sentenciadeasignacion ::= parteizquierdaasignacion:pi ASIGNACION parametroasignacion:pd DSENTENCIAS
	{:
		//Compruebo si concuerdan los tipos de la parte izquierda y derecha y qué tipòs son, según sea seteo la SentenciaAsignacion.
		if((pi.getType().getName().equals("entero") && pd.getType().getName().equals("entero"))){
			RESULT = new SentenciaAsignacion(pi, pd, "entero");
		} else if(pi.getType().getName().equals("boolean") && pd.getType().getName().equals("boolean")){
			RESULT = new SentenciaAsignacion(pi,pd,"boolean");
		} else
			throw new RuntimeException("No se puede asignar a una variable de tipo " + pi.getType()-getName() + " una expresión de tipo " );
	:}; 
parametroasignacion ::= expresion:ex
	{:
		RESULT = ex;
	:};

// llamada a función
parametrofuncionoproc ::=     listavariables ;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;


// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion ;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon ;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;


// escribir. 
parametroEscribir ::= STRING | expresion | epsilon ;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS;



